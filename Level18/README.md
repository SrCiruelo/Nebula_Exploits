__LEVEL18 code:__
```c
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <stdio.h>
#include <sys/types.h>
#include <fcntl.h>
#include <getopt.h>

struct {
  FILE *debugfile;
  int verbose;
  int loggedin;
} globals;

#define dprintf(...) if(globals.debugfile) \
  fprintf(globals.debugfile, __VA_ARGS__)
#define dvprintf(num, ...) if(globals.debugfile && globals.verbose >= num) \
  fprintf(globals.debugfile, __VA_ARGS__)

#define PWFILE "/home/flag18/password"

void login(char *pw)
{
  FILE *fp;

  fp = fopen(PWFILE, "r");
  if(fp) {
      char file[64];

      if(fgets(file, sizeof(file) - 1, fp) == NULL) {
          dprintf("Unable to read password file %s\n", PWFILE);
          return;
      }
                fclose(fp);
      if(strcmp(pw, file) != 0) return;       
  }
  dprintf("logged in successfully (with%s password file)\n",
      fp == NULL ? "out" : "");
  
  globals.loggedin = 1;

}

void notsupported(char *what)
{
  char *buffer = NULL;
  asprintf(&buffer, "--> [%s] is unsupported at this current time.\n", what);
  dprintf(what);
  free(buffer);
}

void setuser(char *user)
{
  char msg[128];

  sprintf(msg, "unable to set user to '%s' -- not supported.\n", user);
  printf("%s\n", msg);

}

int main(int argc, char **argv, char **envp)
{
  char c;

  while((c = getopt(argc, argv, "d:v")) != -1) {
      switch(c) {
          case 'd':
              globals.debugfile = fopen(optarg, "w+");
              if(globals.debugfile == NULL) err(1, "Unable to open %s", optarg);
              setvbuf(globals.debugfile, NULL, _IONBF, 0);
              break;
          case 'v':
              globals.verbose++;
              break;
      }
  }

  dprintf("Starting up. Verbose level = %d\n", globals.verbose);

  setresgid(getegid(), getegid(), getegid());
  setresuid(geteuid(), geteuid(), geteuid());
  
  while(1) {
      char line[256];
      char *p, *q;

      q = fgets(line, sizeof(line)-1, stdin);
      if(q == NULL) break;
      p = strchr(line, '\n'); if(p) *p = 0;
      p = strchr(line, '\r'); if(p) *p = 0;

      dvprintf(2, "got [%s] as input\n", line);

      if(strncmp(line, "login", 5) == 0) {
          dvprintf(3, "attempting to login\n");
          login(line + 6);
      } else if(strncmp(line, "logout", 6) == 0) {
          globals.loggedin = 0;
      } else if(strncmp(line, "shell", 5) == 0) {
          dvprintf(3, "attempting to start shell\n");
          if(globals.loggedin) {
              execve("/bin/sh", argv, envp);
              err(1, "unable to execve");
          }
          dprintf("Permission denied\n");
      } else if(strncmp(line, "logout", 4) == 0) {
          globals.loggedin = 0;
      } else if(strncmp(line, "closelog", 8) == 0) {
          if(globals.debugfile) fclose(globals.debugfile);
          globals.debugfile = NULL;
      } else if(strncmp(line, "site exec", 9) == 0) {
          notsupported(line + 10);
      } else if(strncmp(line, "setuser", 7) == 0) {
          setuser(line + 8);
      }
  }

  return 0;
}

```

We have a pretty long code so let's go step by step but first let's check permissions 

```sh
C:\Users\migue\Documents\Nebula_Exploits\Level18>nc -l -p 8888
level18@nebula:/home/flag18$ ls -lh
ls -lh
total 13K
-rwsr-x--- 1 flag18 level18 12K 2011-11-20 21:22 flag18int
-rw------- 1 flag18 flag18   37 2011-11-20 21:22 password
level18@nebula:/home/flag18$   
```
as we can see the suid bit, so is we gain acces over the flag18 program we can get flag18 permissions

```c

struct {
  FILE *debugfile;
  int verbose;
  int loggedin;
} globals;

```
First we have a global variable called globals with attributes:
1. debugfile, a file pointer to what I suppose is a file for printing erros,
2. verbose, an integer that I think is used as a boolean
3. loggedin, an integer and just like verbose I think it is used as a boolean
```c
#define dprintf(...) if(globals.debugfile) \
  fprintf(globals.debugfile, __VA_ARGS__)
#define dvprintf(num, ...) if(globals.debugfile && globals.verbose >= num) \
  fprintf(globals.debugfile, __VA_ARGS__)

#define PWFILE "/home/flag18/password"

```
We have defines for creating fast functions to print to the debugfile
__VA__ARGS__ is variadic macro for passing the variadic arguments to the real function.
#### [MORE ON VARIADIC MACROS](https://gcc.gnu.org/onlinedocs/cpp/Variadic-Macros.html)

Also the path of a file storing a password is defined.
```c
void login(char *pw)
{
  FILE *fp;

  fp = fopen(PWFILE, "r");
  if(fp) {
      char file[64];

      if(fgets(file, sizeof(file) - 1, fp) == NULL) {
          dprintf("Unable to read password file %s\n", PWFILE);
          return;
      }
                fclose(fp);
      if(strcmp(pw, file) != 0) return;       
  }
  dprintf("logged in successfully (with%s password file)\n",
      fp == NULL ? "out" : "");
  
  globals.loggedin = 1;

}

```
The function login opens the password file and compares a Cstring passed by argument to the string
in the password file, we have no permission over the password file and the directory that the file 
is in. The acces is through a full path so I don't think we have any vulnerability here.

```c
void notsupported(char *what)
{
  char *buffer = NULL;
  asprintf(&buffer, "--> [%s] is unsupported at this current time.\n", what);
  dprintf(what);
  free(buffer);
}
```
This function prints a defined message,that changes with the argument and then prints the argument to the debugfile.
```c
void setuser(char *user)
{
  char msg[128];

  sprintf(msg, "unable to set user to '%s' -- not supported.\n", user);
  printf("%s\n", msg);

}
```
This function prints a defined message that changes with the username, the function doesn't check for length of the string,
so we might be able to bufferoverflow this program deppending on how it was compiled.

Let's go step by step with main function, as it is huge:
```c
  char c;

  while((c = getopt(argc, argv, "d:v")) != -1) {
      switch(c) {
          case 'd':
              globals.debugfile = fopen(optarg, "w+");
              if(globals.debugfile == NULL) err(1, "Unable to open %s", optarg);
              setvbuf(globals.debugfile, NULL, _IONBF, 0);
              break;
          case 'v':
              globals.verbose++;
              break;
      }
  }

```

We have while loop that is used for reading the command line arguments:
-d optarg: opens a global debugfile in the path defined by optarg
-v: sets the verbose to one, so the program prints process information

Now let's check the infinite loop

```c 
      char line[256];
      char *p, *q;

      q = fgets(line, sizeof(line)-1, stdin); //q points to line now
      if(q == NULL) break; 
      p = strchr(line, '\n'); if(p) *p = 0; 
      p = strchr(line, '\r'); if(p) *p = 0; 

      dvprintf(2, "got [%s] as input\n", line);

```

Reads from the use input and checks if for the end of the line if it finds end of line the program substitutes it with a end of string

```c

      if(strncmp(line, "login", 5) == 0) {
          dvprintf(3, "attempting to login\n");
          login(line + 6);
      } else if(strncmp(line, "logout", 6) == 0) {
          globals.loggedin = 0;
      } else if(strncmp(line, "shell", 5) == 0) {
          dvprintf(3, "attempting to start shell\n");
          if(globals.loggedin) {
              execve("/bin/sh", argv, envp);
              err(1, "unable to execve");
          }
          dprintf("Permission denied\n");
      } else if(strncmp(line, "logout", 4) == 0) {
          globals.loggedin = 0;
      } else if(strncmp(line, "closelog", 8) == 0) {
          if(globals.debugfile) fclose(globals.debugfile);
          globals.debugfile = NULL;
      } else if(strncmp(line, "site exec", 9) == 0) {
          notsupported(line + 10);
      } else if(strncmp(line, "setuser", 7) == 0) {
          setuser(line + 8);
      }
```
This is the final peace of code, it gets the user input and compares it to different string
depending on the string different functions get executed:
..* login [pass] executes de login function with pass as argument
..* logout sets the loggedin bit to 0
..* shell checks if the user is logged in and then executes a new command line



